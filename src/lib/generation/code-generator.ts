import { getTemplateById } from '../../templates/index.js';
import type { AgentTemplate, ToolConfiguration } from '../../types/agent.js';

export interface CodeGenerationOptions {
  templateId: string;
  agentName: string;
  includeComments?: boolean;
  includeErrorHandling?: boolean;
  includeSampleUsage?: boolean;
}

export class CodeGenerator {
  /**
   * Generate complete agent code implementation
   */
  generateFullCode(options: CodeGenerationOptions): string {
    const template = getTemplateById(options.templateId);
    if (!template) {
      throw new Error(`Template ${options.templateId} not found`);
    }

    const {
      includeComments = true,
      includeErrorHandling = true,
      includeSampleUsage = true
    } = options;

    const sections = [
      this.generateImports(template, includeComments),
      this.generateUtilities(template, includeComments),
      this.generateToolImplementations(template, includeComments, includeErrorHandling),
      this.generateAgentInitialization(template, options.agentName, includeComments),
      this.generateMainFunction(template, includeComments, includeErrorHandling),
      includeSampleUsage ? this.generateSampleUsage(includeComments) : ''
    ];

    return sections.filter(Boolean).join('\n\n');
  }

  /**
   * Generate import statements
   */
  private generateImports(template: AgentTemplate, includeComments: boolean): string {
    const lines: string[] = [];

    if (includeComments) {
      lines.push('/**');
      lines.push(` * ${template.name} - Agent Implementation`);
      lines.push(` * ${template.description}`);
      lines.push(' * Generated by Agent Advisor MVP');
      lines.push(' */');
      lines.push('');
    }

    lines.push("import { Agent } from '@anthropic-ai/claude-agent-sdk';");
    lines.push("import { tool } from '@anthropic-ai/claude-agent-sdk';");
    lines.push("import { z } from 'zod';");
    lines.push("import { getMinimaxConfig } from './config.js';");

    if (includeComments) {
      lines.push('');
      lines.push('// Additional imports for specific capabilities');
    }

    // Add conditional imports based on template capabilities
    if (template.capabilityTags.includes('file-access')) {
      lines.push("import { readFile, writeFile } from 'fs/promises';");
    }
    if (template.capabilityTags.includes('web-access')) {
      lines.push("import { fetch } from 'undici';");
    }

    return lines.join('\n');
  }

  /**
   * Generate utility functions
   */
  private generateUtilities(template: AgentTemplate, includeComments: boolean): string {
    const lines: string[] = [];

    if (includeComments) {
      lines.push('/**');
      lines.push(' * Utility Functions');
      lines.push(' */');
      lines.push('');
    }

    lines.push('function handleError(error: unknown, context: string): string {');
    lines.push('  const message = error instanceof Error ? error.message : String(error);');
    lines.push('  console.error(`Error in ${context}:`, message);');
    lines.push('  return `Operation failed: ${message}`;');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate tool implementations
   */
  private generateToolImplementations(template: AgentTemplate, includeComments: boolean, includeErrorHandling: boolean): string {
    const sections: string[] = [];

    if (includeComments) {
      sections.push('/**');
      sections.push(' * Tool Implementations');
      sections.push(' */');
      sections.push('');
    }

    template.defaultTools.forEach(toolConfig => {
      sections.push(this.generateSingleTool(toolConfig, includeComments, includeErrorHandling));
    });

    return sections.join('\n\n');
  }

  /**
   * Generate a single tool implementation
   */
  private generateSingleTool(toolConfig: ToolConfiguration, includeComments: boolean, includeErrorHandling: boolean): string {
    const lines: string[] = [];
    const toolName = this.toCamelCase(toolConfig.name);

    if (includeComments) {
      lines.push(`/**`);
      lines.push(` * ${toolConfig.description}`);
      lines.push(` * Permissions: ${toolConfig.requiredPermissions.join(', ')}`);
      lines.push(` */`);
    }

    // Generate Zod schema from parameters
    lines.push(`const ${toolName}Schema = z.object({`);
    const params = toolConfig.parameters as Record<string, any>;
    Object.entries(params).forEach(([key, value]) => {
      const zodType = this.inferZodType(value);
      lines.push(`  ${key}: ${zodType},`);
    });
    lines.push('});');
    lines.push('');

    // Generate tool function
    lines.push(`export const ${toolName}Tool = tool(`);
    lines.push(`  '${toolConfig.name}',`);
    lines.push(`  '${toolConfig.description}',`);
    lines.push(`  ${toolName}Schema.shape,`);
    lines.push(`  async (input: z.infer<typeof ${toolName}Schema>) => {`);

    if (includeErrorHandling) {
      lines.push('    try {');
      lines.push('      // TODO: Implement tool logic here');
      lines.push('      const result = { status: "success", message: "Tool executed successfully" };');
      lines.push('      ');
      lines.push('      return {');
      lines.push('        content: [{');
      lines.push('          type: "text" as const,');
      lines.push('          text: JSON.stringify(result, null, 2)');
      lines.push('        }]');
      lines.push('      };');
      lines.push('    } catch (error) {');
      lines.push(`      return {`);
      lines.push(`        content: [{`);
      lines.push(`          type: "text" as const,`);
      lines.push(`          text: JSON.stringify({ status: "error", error: handleError(error, '${toolConfig.name}') }, null, 2)`);
      lines.push(`        }]`);
      lines.push(`      };`);
      lines.push('    }');
    } else {
      lines.push('    // TODO: Implement tool logic here');
      lines.push('    const result = { status: "success", message: "Tool executed successfully" };');
      lines.push('    ');
      lines.push('    return {');
      lines.push('      content: [{');
      lines.push('        type: "text" as const,');
      lines.push('        text: JSON.stringify(result, null, 2)');
      lines.push('      }]');
      lines.push('    };');
    }

    lines.push('  }');
    lines.push(');');

    return lines.join('\n');
  }

  /**
   * Generate agent initialization code
   */
  private generateAgentInitialization(template: AgentTemplate, agentName: string, includeComments: boolean): string {
    const lines: string[] = [];

    if (includeComments) {
      lines.push('/**');
      lines.push(' * Agent Configuration and Initialization');
      lines.push(' */');
      lines.push('');
    }

    lines.push('const config = getMinimaxConfig();');
    lines.push('');
    lines.push(`const ${this.toCamelCase(agentName)}Agent = new Agent({`);
    lines.push('  model: config.model,');
    lines.push('  apiKey: config.apiKey,');
    lines.push('  baseUrl: config.baseUrl,');
    lines.push('  systemPrompt: `');

    // Add first few lines of system prompt
    const promptLines = template.systemPrompt.split('\n').slice(0, 5);
    promptLines.forEach(line => {
      lines.push(`${line}`);
    });
    lines.push('  `,');

    lines.push('  tools: [');
    template.defaultTools.forEach((tool, idx) => {
      const comma = idx < template.defaultTools.length - 1 ? ',' : '';
      lines.push(`    ${this.toCamelCase(tool.name)}Tool${comma}`);
    });
    lines.push('  ]');
    lines.push('});');

    return lines.join('\n');
  }

  /**
   * Generate main function
   */
  private generateMainFunction(template: AgentTemplate, includeComments: boolean, includeErrorHandling: boolean): string {
    const lines: string[] = [];

    if (includeComments) {
      lines.push('/**');
      lines.push(' * Main execution function');
      lines.push(' */');
    }

    lines.push('async function main() {');

    if (includeErrorHandling) {
      lines.push('  try {');
      lines.push('    console.log("Starting agent...");');
      lines.push('    await agent.run();');
      lines.push('  } catch (error) {');
      lines.push('    console.error("Agent execution failed:", error);');
      lines.push('    process.exit(1);');
      lines.push('  }');
    } else {
      lines.push('  console.log("Starting agent...");');
      lines.push('  await agent.run();');
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate sample usage documentation
   */
  private generateSampleUsage(includeComments: boolean): string {
    if (!includeComments) return '';

    const lines: string[] = [];
    lines.push('/**');
    lines.push(' * Usage:');
    lines.push(' * 1. Set up environment variables in .env file');
    lines.push(' * 2. Install dependencies: npm install');
    lines.push(' * 3. Build: npm run build');
    lines.push(' * 4. Run: npm start');
    lines.push(' * ');
    lines.push(' * Environment Variables:');
    lines.push(' * - MINIMAX_JWT_TOKEN: Your MiniMax API JWT token (required)');
    lines.push(' * - CLI_PATH: Optional path to Claude CLI');
    lines.push(' * - LOG_LEVEL: Logging level (default: info)');
    lines.push(' * - NODE_ENV: Environment mode (default: development)');
    lines.push(' */');
    lines.push('');
    lines.push('// Start the agent');
    lines.push('if (import.meta.url === `file://${process.argv[1]}`) {');
    lines.push('  main();');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Convert snake_case to camelCase
   */
  private toCamelCase(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }

  /**
   * Infer Zod type from parameter definition
   */
  private inferZodType(param: any): string {
    if (typeof param === 'string') {
      return 'z.string()';
    }
    if (typeof param === 'number') {
      return 'z.number()';
    }
    if (typeof param === 'boolean') {
      return 'z.boolean()';
    }
    if (Array.isArray(param)) {
      return 'z.array(z.unknown())';
    }
    if (typeof param === 'object' && param !== null) {
      if (param.type === 'string') return 'z.string()';
      if (param.type === 'number') return 'z.number()';
      if (param.type === 'boolean') return 'z.boolean()';
      if (param.type === 'array') return 'z.array(z.unknown())';
    }
    return 'z.unknown()';
  }
}
